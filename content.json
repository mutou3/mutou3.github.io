{"meta":{"title":"爱自由","subtitle":null,"description":null,"author":"The Answer","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-09-21T16:31:20.000Z","updated":"2018-09-21T16:32:41.311Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-21T15:23:48.000Z","updated":"2018-09-21T15:28:47.342Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"vim编辑器","slug":"vim编辑器","date":"2019-02-19T15:34:29.000Z","updated":"2019-02-16T16:02:56.874Z","comments":true,"path":"2019/02/19/vim编辑器/","link":"","permalink":"http://yoursite.com/2019/02/19/vim编辑器/","excerpt":"","text":"vim +文件名 直接打开文件，进入到命令模式（老段视频第10章）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"vim编辑器","slug":"vim编辑器","permalink":"http://yoursite.com/tags/vim编辑器/"}]},{"title":"磁盘和文件系统","slug":"磁盘和文件系统的管理","date":"2019-02-18T15:34:29.000Z","updated":"2019-02-16T16:02:48.324Z","comments":true,"path":"2019/02/18/磁盘和文件系统的管理/","link":"","permalink":"http://yoursite.com/2019/02/18/磁盘和文件系统的管理/","excerpt":"","text":"linux支持文件系统查看磁盘大小：df -h 以易读的方式显示磁盘使用情况du -sh -s选项表示只单独查看该文件的大小，若不跟选项-s会把文件夹下的所有的文件大小都显示出来。 连接文件软连接相当于window中的快捷方式；创建软连接的方式命令：ln -s 文件名 软链接文件名 表示创建了aal为aa的软连接（快捷方式）硬链接：同一个文件有几个名字，创建硬链接的命令为：ln 文件名 硬链接文件名对磁盘分区：命令fdisk,命令：fdisk -l 直接显示所有的硬盘和分区创建分区：fdisk /dev/sda 对硬盘进行分区。所以后面跟硬盘名主分区最多只有4个，重新创建分区标后，需要更新分区表命令：partprobe划好分区后，分区不能直接使用，需要格式化新建的分区，命令：mkfs -t ext3 /dev/sda5 或者 mkfs.ext3 /dev/sda5…若要指定block size的大小，需要指定 mkfs.ext3 -b 4096 /dev/sda5.。。默认的block size为1024k格式化好后若要使用还必须要挂载：mount /磁盘检验 fsck 对整个分区进行检查 fsck /dev/sda5检测系统坏道：badblocks /dev/sda5挂载分区：必须要把分区挂载到某个目录下命令：mount 外部设备 目录mount /dev/sda5 /mntumount 外部设备 或者 umount 挂载点mount -o remount,ro /mnt 以只读的形式重新挂载/mntmount -o remount,rw /mnt 以只读和写的形式重新挂载/mntmount -o remount,noexcu /mnt 以没有可以执行权限重新挂载/mnt若卸载的是后提示，设备正在使用，可以使用命令fuser -mv /mnt查看到底是那个进程正在使用该设备以上使用mount挂载的是临时挂载，关机后就没在挂载了挂载镜像 mount -o loop XX.iso /mnt 挂载镜像使用参数loop设置开机挂载配置文件为：/etc/fstab 文件最左边为设备名 中间为挂载点 然后为文件系统 默认权限 第一个数字（是否做备份） 第二个数字（开机时是否进行fsck进行检查）查看磁盘参数 tune2fs -l /dev/sda5 创建交换分区 查看交换分区 cat /proc/swaps diff +文件 +文件 对比两个文件的区别 文件与文件系统的压缩与打包压缩命令：gzip + 文件名 （源文件也不存在了） zcat + 压缩文件的名字 （不解压的情况下，也可以查看压缩文件的内容）gzip -c hosts &gt; hosts.gz 保留源文件bzip2 hosts 源文件也不存在了 bzip2 -c &gt; hosts.bz2 保留源文件 bzcat + 压缩文件名 也可以查看内容zip hosts.zip hosts 解压直接运行：unzip hosts.zip 打包：tar tar -tvf +打包文件名 （不解压的时，查看打包文件的内容）指定解压的路径：tar -xvf hosts.tar -C aa/ 指定解压到aa目录下指定解压的某个文件： tar -xvf xx.tar 文件名 （指定解压这一个文件名出来）tar -czvf xxx.tar.gz xxx –remove-files (移除源文件进行打包压缩) gz后缀压缩tar -jcvf xxx.tar.bz2 xxx –remove-files （移除源文件进行打包压缩） bz2后缀压缩tar -jxvf xxx.tar.bz2 解压后缀为bz2的压缩文件tar -jxvf xxx.tar.gz2 -C aa/ （指定解压文件到哪个目录下） 备份备份分为3种，全备份，增量备份，差异备份dump -数字（数字代表备份级别，只会从上次备份级别比他小的备份开始备份）增量备份，级别是依次增大，差异备份，级别依次减小 dump -0u -f rhce/1.dump /dev/sda3 （该命令表示对分区sda3进行全备份，并将备份文件存储在当前路径的rhce/下面，u表示将备份的日志写到/etc/dumpdatas下） 恢复备份restore -t -f 备份.dump 文件 （-t表示不恢复的时候查看备份文件的内容）restore -r -f /root/rhce/1.dump (-f指定恢复的文件)（-r 把所有的备份文件全部恢复出来）restore -i -f /root/rhce/1.dump (该命令会有一个交互，可以选定具体恢复哪些文件) 新建镜像：mkisofs -o xx.iso 文件名 文件名 （创建镜像）挂载镜像：mount -o loop xx.iso /mnt (挂载镜像)cp /dev/cdrom/ xxx.iso (直接把光盘拷贝为镜像) （然后挂载就可以使用）dd if=/dev/zero of=file4 bs=1M count=1dd if=/dev/sda of=/dev/sdbdd if=/dev/sda3 of=test (把sda3的数据全部整合到test里面)dd if=test of=/dev/sda3 (把test的数据恢复到sda3中去)dd if=/dev/sda1 of=/dev/sda2 (把sda1的数据拷贝到sda2分区里面去) find -name ‘file*’ |cpio -o &gt; xx.cpio（把文件名包含有file的文件打包到 xx.cpio）cpio -iu &lt;xx.cpio (把xx.cpio解包)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"磁盘和文件系统","slug":"磁盘和文件系统","permalink":"http://yoursite.com/tags/磁盘和文件系统/"}]},{"title":"文件权限与目录配置","slug":"linux的文件权限与目录配置","date":"2019-02-17T15:34:29.000Z","updated":"2019-02-16T16:02:42.702Z","comments":true,"path":"2019/02/17/linux的文件权限与目录配置/","link":"","permalink":"http://yoursite.com/2019/02/17/linux的文件权限与目录配置/","excerpt":"","text":"文件权限与目录配置用户的信息保存在/etc/passwd文件中用户的密码存放在/etc/shadow用户组的信息存放在/etc/grouplinux中系统是根据 uid来识别用户的，每一个用户对应一个uid 环境变量 ls -l 以长模式的形式查看目录下的文件。 第一列为权限第二列为文件的硬链接数第三列 为文件的所有者第四列 为文件的所属组文件以：- 普通文件 d: 目录 b：设备文件（块设备：可以用来存储东西的文件，U盘，硬盘，光驱） c： 设备文件（字符型文件，鼠标、键盘、等硬件）l: 指快捷方式（软连接） 使用chmod 改权限 chmod u+x,g+w,o+r 文件名chmod u=rw 文件名 前置将user的权限改为rw 文件夹必须要有 X 权限才能cd 进去查看文件属性使用命令 file + 文件名 ## 切换目录 cd - 切换到上一次的目录linux中拷贝快捷方式，是直接拷贝源文件为目的文件 若只拷贝快捷方式则需要加上 -dlinux中拷贝文件:若要拷贝文件的属性，这需要在命令后面加上 选项 -p ##文件查看cat -n 文件名，，查看文件时第一列显示 行数more 从上往下显示，按回车一行一行的往下显示，按空格一屏幕的往下，，more 分屏显示less less支持往前和往后看。按pageup和pagedown，其他的和more相同，在less里面支持查找，按命令/，按n从上往下依次查找，N从下往上查找。head 查看文件的头几行，默认前10行，若其他的行，这使用命令head -5 文件，查看文件的前5行tail 查看文件的尾5行， 若查看其他行，则使用命令 tail -6 文件，查看文件尾5行。 tail -f 文件名 实时查看文件写入情况以上命令只能查看文本文件若要查看二进制文件，则使用命令：od -t c 文件名查看非纯文本文件使用命令：strings 文件名 创建一个文件：touch 文件名 如果某个文件已经存在的情况下，就是将已经存在的文件的时间改为创建的当前时间 umask 权限过滤符，值代表被过滤的权限。文件默认的权限为666 文件夹默认的权限为 777 。 然后过滤掉umask值存在的权限 chattr lsattr查看隐藏权限 chattr +a 文件夹 表示该文件夹下面只能添加文件不能删除 chattr +i 文件夹 表示该文件夹下面文件不能添加也不能删除 特殊权限：SUID ，若一个命令的所有者权限时候有S的时候，其他用户自行该命令时，也具有所有者的权限。SGID： #命令与文件的查询查看命令在哪个路径：which +命令 或者 where is + 命令locate +文件名 根据/var/lib/mlocate/mlocate.db数据库里面的内容进行查找，每一天更新一次，若要手动更新的换，执行命令 updatedb，locate +i +文件名 不区分大小写 find 目录 -属性 值 （未指定目录的话，就在当前路径下查找）属性name size perm（权限）等属性","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"权限与目录","slug":"权限与目录","permalink":"http://yoursite.com/tags/权限与目录/"}]},{"title":"使用存储过程","slug":"使用存储过程","date":"2019-02-17T09:52:56.000Z","updated":"2019-02-17T09:53:57.126Z","comments":true,"path":"2019/02/17/使用存储过程/","link":"","permalink":"http://yoursite.com/2019/02/17/使用存储过程/","excerpt":"","text":"存储过程存储过程简单来说，就是为以后的使用而保存的一条或多条Mysql语句的集合，可将其视为批文件，虽然他们的作用不仅限于批处理。 执行存储过程 mysql称存储过程为调用，因此mysql执行存储过程的语句为CALL。CALL接收存储过程的名字以及需要传递给它的任意参数。 创建存储过程存储过程其实就是定义的函数，直接调用即可。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。变量：内存中一个特定的位置，用来临时存储数据。1234567891011121314151617181920CREATE PROCEDURE productpricing( OUT pl DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT MIN(prod_price) INTO pl FROM products; SELECT MAX(prod_price) INTO ph FROM products; SELECT AVG(prod_price) INTO pa FROM products;END;#此存储过程接收3个参数：pl存储产品的最低价格，ph存储产品最高价格，pa存储产品的平均价格。每个参数必须具有指定的类型。关键字out指出相应的参数用来从存储过程传出一个值（返回给调用者），mysql支持IN（传递给存储过程）、OUT（从存储过程传出）和INTO（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内。此处为select语句用来检索数据，然后保存到相应的变量（通过指定INTO关键字）。 调用12345CALL productpricing(@pricelow,@pricehigh,@priceaverage);#调用该存储过程mysql所有的变量都必须以@开始。在调用时这条语句并不显示任何结果，结果都已经存储在变量中SELECT @pricelow AS gg,@pricehigh,@priceaverage;#为了显示值，必须用以上语句，重新检索出变量中的值。 1234567891011121314CREATE PROCEDURE ordertotal( IN onumber INT, OUT ototal DECIMAL(8,2))BEGIN SELECT SUM(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;onumber定义为IN，因为订单号被传入存储过程。ototal定义为out，因为要从存储过程返回合计。INTO使用ototal存储计算出来合计。CALL ordertotal(20005,@tatal);SELECT @tatal;#调用该函数必须传递两个参数，第一个参数为订单号，第二个为变量名。 迄今为止，使用的所有存储过程基本上都是封装mysql简单的select语句。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"存储过程","slug":"存储过程","permalink":"http://yoursite.com/tags/存储过程/"}]},{"title":"视图","slug":"视图","date":"2019-02-17T09:50:55.000Z","updated":"2019-02-17T09:52:31.471Z","comments":true,"path":"2019/02/17/视图/","link":"","permalink":"http://yoursite.com/2019/02/17/视图/","excerpt":"","text":"视图视图的定义 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 为什么使用视图 重用视图 简化复杂的SQL操作，在编写查询后，可以方便地重用它而不必要知道它的细节 使用表的组成部分而不是整个表 保护数据。可以授予部分权限 更改数据格式和表示。视图可以返回与底层表的表示和格式不同的数据在视图创建之后，可以用与表基本相同的方式利用他们。可以将视图执行select操作，过滤和排序数据，将试图联结到其他视图或表。重要的是知道视图仅仅用来查看存储在别处的数据的一种设施。试图本身不包含数据，因此他们返回的数据是从其他表中检索出来的 使用视图。 视图用creat view 语句来创建。 使用show creat view viewname，来查看创建视图的语句。 用drop删除视图，其语法为drop view viewname； 更新视图时，可以先用drop在用creat，也可以直接用creat orreplace view。 利用视图简化复杂的联结。 视图的最常见的应用之一就是隐藏复杂的SQL，这通常都会涉及联结。123CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id AND orderitems.order_num = orders.order_num;#创建一个名为productcustomers的视图。它联结三个表，如果执行select * from productcustomers，将列出订购了任意产品的顾客。 12SELECT * FroM productcustomers WHERE prod_id LIKE &apos;TNT%&apos;;#使用视图查询购买了产品TNT2的客户； 用视图重新格式化检索出的数据视图的另外一种用途就是重新格式化检索出的数据。12SELECT CONCAT(Rtrim(vend_name),&apos;(&apos;,Rtrim(vend_country),&apos;)&apos;) AS vend_title FROM vendors order by vend_name;#合并一列检索出的数据，可以添加视图重用 12345CREATE VIEW vendorlocations AS SELECT CONCAT(Rtrim(vend_name),&apos;(&apos;,Rtrim(vend_country),&apos;)&apos;) AS vend_title FROM vendors order by vend_name;#创建格式化检索的数据的视图。SELECT * FROM vendorlocations;#直接使用视图，查询而不用每一次都编写复杂的语句。 1234CREATE VIEW customersemaillist AS SELECT cust_id,cust_name,cust_email FROM customers WHERE cust_email IS NOT NULL;#创建排除表中没有email的客户的视图select * from customeremaillist; 使用视图计算字段视图对于简化字段的使用特别有用 12345CREATE VIEW orderitemsexpanded AS SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM orderitems;#创建视图select * from orderitemsexpanded where orer_num = 20005;#使用视图检索订单为20005的数据。从而是sql语句简单化。 更新视图通常视图是可以更新的（即可以使用insert，update和delete）。更新一个视图将更新其基表。如果你对视图增加或是删除行，实际上是对其基表增加或删除行。 总结视图就是使用虚拟的表，以替代复杂的sql语句，该虚拟表，及为创建该视图时候的sql所检索出的数据，作为虚拟的表来使用。 使用存储过程存储过程 存储过程迄今为止，使用的大多数sql语句都是针对一个或多个表的单条语句，并非所有操作都有这么简单，经常会有一个完整的操作需要多条语句才能完成。 存储过程简单来说，就是为以后的使用而保存的一条或多条mysql语句的集合，可以将其视为批文件，虽然他们的作用不仅限于批处理 使用存储过程的原因 通过把处理封装在容易使用的单元中，简化复杂的操作。 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"视图","slug":"视图","permalink":"http://yoursite.com/tags/视图/"}]},{"title":"插入数据","slug":"插入数据","date":"2019-02-17T09:49:27.000Z","updated":"2019-02-17T09:50:16.987Z","comments":true,"path":"2019/02/17/插入数据/","link":"","permalink":"http://yoursite.com/2019/02/17/插入数据/","excerpt":"","text":"数据插入分类 插入完整的行把数据插入表中最简单的方法是使用基本的INSERT语法。它要求指定表名和被插入到新行中的值。 1234567891011INSERT INTO customers VALUES (NULL, &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); #使用该语句插入时，要确保值与列对应，容易出错，风险较大，一般不使用。 1234567891011121314151617 INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)VALUES(&apos;Pep E. Lapew&apos;,&apos;100 Main Street&apos;,&apos;Los Angeles&apos;,&apos;CA&apos;,&apos;90046&apos;,&apos;USA&apos;,NULL,NULL);#该语句指定了表的列名，值的位置和列对应，不需要的列可以不体现出来，及忽略，顺序也可以随机，只要对应。 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下条件 该列定义为允许NULL（无值或空值） 在表定义中给出默认值。这表示如果不给出值，将使用默认值。 如果对表中的不允许NULL值且没有默认值的列不给出值。 插入行的一部分 插入多行 插入某些查询的结果123INSERT INTO customers(cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country) SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country FROM custnew;#select 中列出的每个列对应于customers表名后所跟的列表中的每个列。 select语句可以包含where子句以过滤插入的数据。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"插入数据","slug":"插入数据","permalink":"http://yoursite.com/tags/插入数据/"}]},{"title":"全文本搜索","slug":"全文本搜索","date":"2019-02-17T09:48:14.000Z","updated":"2019-02-17T09:48:55.280Z","comments":true,"path":"2019/02/17/全文本搜索/","link":"","permalink":"http://yoursite.com/2019/02/17/全文本搜索/","excerpt":"","text":"理解全文本搜索 并非所有的引擎都支持全文本搜索。使用like可以找出包含特殊值或部分值的行（不管这些值位于行内的什么位置）使用全文本搜索时，mysql不需要分别查看每个行，不需要分别分析和处理每个词。mysql创建指定列中的一个索引，搜索可以针对这些词进行。（对索引指定的列进行搜索）。 为了使用全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断的重新索引。在索引之后，select可与match（）和against（）一起使用以实际执行搜索。 一般在创建表时，启用全文本搜索。create table语句接收FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。 1234567891011CREATE TABLE productsnotes (note_id INT not NULL auto_increment,prod_id CHAR(10) NOT NULL,note_date datetime NOT NULL,note_text text NULL,PRIMARY KEY(note_id),FULLTEXT(note_text))ENGINE=MyISAM;#创建productsnotes,FULLTEXT(note_text)的指示对它索引。 进行全文本搜索:在索引之后，使用两个函数Match（）和Against（）执行全文本搜索 1SELECT note_text FROM productnotes WHERE MATCH(note_text) Against(&apos;rabbit&apos;); 此select语句检索单个列note_text。由于where子句，一个全文本搜索被执行。match（note_text）指示mysql针对指定的列进行搜索，against（’against’）指定词rabbit作为搜索文本。使用完整的match（）说明，传递给match（）的值必须与FULLTEXT（）定义中的相同。 全文本搜索的一个重要部分就是对结果排序，具有较高等级的行先返回.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"全文本搜索","slug":"全文本搜索","permalink":"http://yoursite.com/tags/全文本搜索/"}]},{"title":"联结表","slug":"联结表","date":"2019-02-17T09:47:07.000Z","updated":"2019-02-17T09:47:46.349Z","comments":true,"path":"2019/02/17/联结表/","link":"","permalink":"http://yoursite.com/2019/02/17/联结表/","excerpt":"","text":"联结sql最强大的功能之一就是能在数据检索查询的执行中联结（join）表。在能够有效的使用联结前，必须要了解关系表中以及关系数据库设计的一些基础知识。 1.关系表关系表的设计就是要保证把信息信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relationship）互相关联。外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。维护引用完整性：重要的是，要理解联结不是物理实体，它在数据库的实际表中不存在。联结由mysql根据需要建立，它存在于查询的执行当中。 2.创建联结 规定要联结的所有表以及他们如何关联即可。 123SELECT vend_name,prod_name,prod_price FROM vendors,products where vendors.vend_id=products.vend_id order by vend_name,prod_name;##products，vendors就是由select联结的两个表。where子句确认他们的联结关系。用第一个id去匹配第二张表中的id。 内部联结目前为止，所使用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也称为内部联结。 12select vend_name,prod_name,prod_price from vendors INNERJOIN products ON vendors.vend_id = products.vend_id;##该语句的from子句组成部分，以inner join 指定。，联结条件用on子句来指定，而不是where。 联结多个表sql对一条select语句中可以联结的表的数目没有没有限制。创建联结的基本规则也相同。首先列出所有的表，然后定义表之间的关系。 123SELECT prod_name,vend_name,prod_price, quantity FROM orderitems,products,vendors WHERE products.vend_id=vendors.vend_id AND orderitems.prod_id=products.prod_id AND order_num = 20005; ##from语句联结3个表，where定义了3个联结条件 子查询并不是执行复杂的select操作的最有效的方式,可以转换为联结查询，得出相同的结果 创建高级联结1.使用表别名123SELECT cust_name,cust_contact FROM customers AS C,orders AS O, orderitems AS oi where c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = &apos;TNT2&apos;;##数据表使用别名 2. 使用不同类型的联结 自联结使用表别名的主要原因之一是能在单条select 语句中不止一次使用相同的表。12SELECT p1.prod_id,p1.prod_name FROM products as p1,products AS p2 where p1.vend_id = p2.vend_id AND p2.prod_id=&apos;DTNTR&apos;; 自然联结通常作为外部语句用来替代从相同表中检索数据时，使用的子查询语句。 2.自然联结无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（内部联结，等值联结）返回所有的数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。12SELECT c.*,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_price FROM customers AS c, orders AS o,orderitems AS oi WHERE c.cust_id=o.cust_id AND oi.order_num = o.order_num AND prod_id = &apos;FB&apos;; 外部联结许多联结将一个表中的行与另外一个表中的行相关联。但是有时候需要包含没有关联行的那些行。为了检索所有客户，包括那些没有订单的客户，需要使用外部联结。 1234SELECT customers.cust_id,orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;##select 语句使用了关键字 outer join 来指定联结的类型（而不是在where子句中指定），在使用outer join 语法时，还必须使用right 或 left 关键字指定包含其所有行的表。（right指出的是outer join右边的表，left指出的是outer join左边的表） 使用带聚集函数的联结检索所有客户，及每个客户所下的订单总数，使用count（）函数代码就可以。 1234SELECT customers.cust_name,customers.cust_id, count(orders.order_num) as num_ord FROM customers INNER JOIN orders on customers.cust_id = orders.cust_id GROUP BY customers.cust_id;##使用inner join 将customers和orders表互相关联。group by 子句按客户分组数据，因此调用count（orders.order_num）对每个客户的订单计数，将他作为num_ord返回 123SELECT customers.cust_name,customers.cust_id, count(orders.order_num) as num_ord FROM customers LEFT OUTER JOIN orders on customers.cust_id = orders.cust_id GROUP BY customers.cust_id;聚集函数也同外部联结来计数，包含没有下订单的客户。 组合查询组合查询 sql允许执行多个查询（多条select语句），并将结果作为单个查询结果返回。这些组合查询通常称为并（union）或复合查询。两种情况需要使用组合查询 在单个查询中从不同的表返回类似结构的数据 对单个表执行多个查询，按单个查询返回数据 创建组合查询可用union操作符来组合数条sql查询。12345SELECT vend_id,prod_id,prod_price FROM products where prod_price &lt;=5 UNION SELECT vend_id,prod_id,prod_price FROM products where vend_id IN (1002,1001);##使用关键字union将两个select 语句组合在一起。并把输出结果组合成单个结果集。在这个简单的例子中，使用union组合查询可能比使用where子句更复杂，但是对于更复杂的过滤条件，或者从多个表中（而不是一个）表中检索数据，使用union更为简单。 规则：union必须由两条或以上的select语句组成，语句之间用关键字union分隔。union中的查询必须使用包含相同的列，表达式或聚集函数（不过各列不需要以相同的次序列出），列数据类型必须兼容，必须完全相同。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"联结表","slug":"联结表","permalink":"http://yoursite.com/tags/联结表/"}]},{"title":"使用函数处理数据及子查询","slug":"使用函数处理数据及子查询","date":"2019-02-17T09:45:00.000Z","updated":"2019-02-17T09:46:05.335Z","comments":true,"path":"2019/02/17/使用函数处理数据及子查询/","link":"","permalink":"http://yoursite.com/2019/02/17/使用函数处理数据及子查询/","excerpt":"","text":"函数sql支持利用函数来处理数据。 使用函数 用于处理文本串（如删除或充值，转换值为大写或小写）的文本函数。 用于在数值上进行算术操作。（如返回绝对值，进行代数运算）的数值函数。 用于处理日期和时间值并从这些值中提取特定的成分（如，返回两个日期之差，检查日期有效性等）的日期和时间函数。 汇总函数 确定表中的行数（或者满足某个条件或包含某个特定值的行数）。 获得表中行组的和。 找出表列（或所有行或某些特定的行）的最大值、最小值和平均值 上述例子都需要对表中数据（而不是实际数据本身）汇总 mysql给出了以下5个聚集函数 函数 |说明 —– | —- avg（） | 返回某列的平均值 count（） | 返回某列的行数 max（）|返回某列的最大值 min（） |返回某列的最小值 sum（）|返回某列之和 12select avg(prod_price) as avg_price from products;查找products表中prod_price列的平均值 count（）函数进行计数。可以利用count（）确定表中行的数目和符和特定条件的行的数目。 count（）函数有两种用法 使用count（*）对表中行的数目进行计数，不管表列中包含的是空值还是非空值。 使用count（column）对特定的列中具有值的行进行计数。12select count(*) as num_cust from products; ##计算表中客户的总数，所有的行。select count(cust_email) as num_cust from products; ##计算列cust_email中的数量，非空。 max（）函数返回指定列中的最大值。max（）要求指定列名。 1select max(prod_price) as max_price from products; ##返回products表中最贵的物品价格。 min（）函数的功能与max（）函数相反。 sum（）函数用来返回指定列的和（总计）。聚集不同的值 以上的5个聚集函数，都可以指定all参数或不给参数（all是默认的） 只包含不同的值，指定distinct（）参数 1select avg(distinct prod_price) as avg_price from products where vend_Id = 1003; ##返回不同价格的平均值，忽略掉价格相同的 组合聚集函数 12select count(*) as num_items,min(prod_price) as min_price,max(prod_price) as max_price, avg(prod_price) as avg_price from products； 分组数据 创建分组 分组是在select语句的group by 子句中建立的。 group by 子句可以包含任意数目的列，这使得能对分组进行嵌套，为数据分组提供更细致的控制12select vend_id,count(*) as num_prods from products group by vend_id;##查询每个供应商的产品的数量。返回供应商id和产品的数量 过滤分组 where过滤的是行，having过滤的是分组。12select cust_id,count(*) as orders from orders group by cust_id having count(*) &gt;=2;##查询两个订单以上。 HAVING和where的差别：where在数据分组前进行过滤，having在数据分组后进行过滤 同时使用where和having过滤的查询语句12select vend_id,count(*) as num_prods from products where prod_price &gt;=10 group by vend_id having count(*) &gt;=2; ##返回具有2个及以上、价格大于等于10的产品供应商。 分组和排序 1234 select order_num,sum(quantity*item_price) as ordertotal from orderitems group by order_num having sum(quantity*item_price)&gt;= 50; ##检索总计订单价格大于等于50的订单号和总计的价格select order_num,sum(quantity*item_price) as ordertotal from orderitems group by order_num having sum(quantity*item_price)&gt;= 50 order by ordertotal； ## 按照总计价格排序 select语句的顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 子查询 迄今为止，所使用的select语句都是都是简单的查询，就是指从一个表中查询出数据。子查询就是将查询结果作为下一个查询查询的过滤条件来使用。（跨表操作） 作为计算字段使用子查询1234567select name,(select count(*) from &quot;MES&quot;.&quot;EMS&quot;.&quot;BREAKER&quot; where &quot;MES&quot;.&quot;EMS&quot;.&quot;BREAKER&quot;.st_id = &quot;MES&quot;.&quot;EMS&quot;.&quot;SUBSTATION&quot;.id）as count_breakers from &quot;MES&quot;.&quot;EMS&quot;.&quot;SUBSTATION&quot;;##select cust_name,cust_state,(select count(*) from orders where orders.cust_id=customers.cust_id) as orders from customers order by cust_name;##此条select语句对customers表中的每个客户返回3列。orders 是一个计算字段，它是圆括号中的子查询建立的。该子查询对检索的每个客户执行一次。 相关子查询：设计外部查询的子查询。这种类型的子查询称为相关子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名有一个句点隔开）","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"函数 子查询","slug":"函数-子查询","permalink":"http://yoursite.com/tags/函数-子查询/"}]},{"title":"创建字段","slug":"创建字段","date":"2019-02-17T09:43:01.000Z","updated":"2019-02-17T09:43:56.427Z","comments":true,"path":"2019/02/17/创建字段/","link":"","permalink":"http://yoursite.com/2019/02/17/创建字段/","excerpt":"","text":"计算字段计算字段 含义 储存在数据库中的数据一般不是应用程序所需要的格式。计算字段并不实际存在于数据库表中，计算字段是运行在select语句内创建的。==字段==基本上就是列的意思。 拼接字段 把两个列拼起来使用concat（）函数。(mysql的不同之处，多数的数据库使用+或者||lai pinjie 而mysql使用concat（）函数) 123select concat（vend_name,&apos;(&apos;,vend_country,&apos;)&apos;） from vendors order by vend_name;select concat(Rtrim(vend_name,&apos;(&apos;,Rtrim(vend_country),&apos;)&apos;) from vendors order by vend_name;##使用函数Rtrim删除数据右侧的空格 使用别名 别名用as关键字赋予。 123select concat(Rtrim(vend_name),&apos;(&apos;,Rtrim(vend_contry),&apos;)&apos; as vend_title from vendors order by vend_name;##使用关键字as创建了一个包含指定计算的名为vend_title的列名。 执行算数计算 算数操作符 | 说明—–|——-+| 加-|减*|乘/|除 123select prod_id,quantity,item_price,quantity*item_price as expanded_price from orderitems where orer_num = 20005;##quantity*item_price 算术计算，expanded_price为as创建出来的计算字段 使用数据处理函数 函数 函数 说明 Left（） 返回串左边的字符 lenth（） 返回串的长度 Locate（） 找出串的一个子串 Lower（） 将串转换为小写 Ltrim（） 删除串左边的空格 Right（） 返回串右边的字符 Rtrim（） 去掉串右边的空格 Upper（） 将串转换为大写 1select vend_name,upper(vend_name) as vend_anme_upcase from vendors; 数据表中有日期和时间 函数 说明 AddDate( ) 增加一个日期（天、周等） AddTime( ) 增加一个时间（时、分等） Curdate( ) 返回当前日期 Curtime（） 返回当前时间 Date（） 返回日期时间的日期部分 DateDiff（） 计算两个日期之差 Date_Add( ) 高度灵活的日期运算函数 Date_Format( ) 返回一个格式化的日期 Day（） 返回一个日期的天数部分 DayofWeek 对于一个日期，返回对应的星期几 Hour（） 返回一个时间的小时部分 Minute（） 返回一个时间的分钟部分 Month（） 返回一个日期的月份部分 Now( ) 返回当前日期和时间 Second（） 返回一个时间的秒部分 Time（） 返回一个日期时间的时间部分 Year（） 返回一个日期的年份部分 1234select cust_id,order_num from orers where Date(order_date) = &apos;2005-09-01&apos;; ##返回日期时间的日期部分## mysql支持的首选日期格式为yyyy-mm-ddselect cust_id,order_num from orders where date(order_date） between ‘2005-09-01’ and ‘2005-09-30’；select cust_id，order_num from orders where Year(order_date) = 2005 and Month(order_date)=9; 常用数值处理函数 函数 说明 Abs（） 返回一个数的绝对值 Cos（） 返回一个角度的余弦 Exp（） 返回一个数的指数值 Mod（） 返回除操作的余数 Pi（） 返回圆周率 Rand（） 返回一个随机数 Sin（） 返回一个角度的正弦 Sqrt（） 返回一个数的平方根 Tan（） 返回一个角度的正切","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"创建字段","slug":"创建字段","permalink":"http://yoursite.com/tags/创建字段/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-02-17T09:40:30.000Z","updated":"2019-02-17T09:42:34.716Z","comments":true,"path":"2019/02/17/正则表达式/","link":"","permalink":"http://yoursite.com/2019/02/17/正则表达式/","excerpt":"","text":"正则表达式正则表达式介绍 正则表达式用法正则表达式：用正则表达式语言来建立，正则表达式语言是一种特殊的语言，与任意语言一样，正则表达式具有特殊的语法和指令；正则表达式是用来匹配文本的特殊的串（字符集合）。如果你想从一个文本中提取电话号码，可以使用正则表达式。如果你需要查找名字中间有数字的所有文件，文本块中找到所有重复的单词，替换一个页面中的所有URL为这些URL的实际HTML连接，也是用正则表达式。正则表达式是用来匹配文本的特殊的串（字符集合）。如果你想从一个文本中提取电话号码，可以使用正则表达式。如果你需要查找名字中间有数字的所有文件，文本块中找到所有重复的单词，替换一个页面中的所有URL为这些URL的实际HTML连接，也是用正则表达式。 使用Mysql正则表达式正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。mysql用where子句对正则表达式提供初步支持，允许你指定正则表达式过滤select检索出的数据。 基本字符匹配 1234select prod_name from products where prod_name regexp &apos;1000&apos; order by prod_name;##关键字like 被regexp 替换，告诉mysql后面跟的是==正则表达式==(与文字正文1000匹配的一个正则表达式）select prod_name from products where prod_name regexp &apos;.000&apos; order by prod_name;这里使用了正则表达式.000 。.是正则表达式中的一个特殊的字符。它表示匹配任意个字符。 like和regexp之间的一个重要差别：like匹配这个列，必须一样才能返回相应的，而regexp在列的值内进行比较，如果被匹配的文本在列值中出现，regexp将会找到它，相应的行将会被返回。一个匹配整个列，一个匹配列中的值进行比较正则表达式不区分大小写，如果要区分的话，可以使用关键字BINARY，如where prod_name regexp BINARY ‘JetPack .000’5.进行or匹配搜索两个串之一（或者），使用管道符 | 123select prod_name from products where prod_name regexp &apos;1000|2000&apos; order by prod_name;##语句中使用了正则表达式1000|2000. | 为正则表达式的OR操作福，同时可以使用两个以上的or条件，例如：&apos;100|2000|3000&apos; 将匹配成1000或2000或3000。 匹配几个字符之一可通过指定任意组用[]括起来的字符来完成。 12select prod_name from products where prod_name regexp &apos;[123] Ton&apos; order by prod_name;##这里使用了正则表达式[123] Ton 。[123]定义一组字符，它的意思是匹配1或者2或者3，因此1 ton 和2 ton 都匹配发挥，因为不区分大小写，所以Ton返回了ton。 字符集也可以被否定，即，匹配出指定字符集外的任何东西。在集合的开头出添加一个 ^,及 [^123],表示匹配除开1,2,3之外的任何东西。 匹配范围集合可以用来匹配一个或多个字符。[123456789]等于[1-9]也可以用来匹配任意字母字符[a-z]. 匹配特殊字符正则表达式语言由具有特定含义的特殊字符构成。为匹配特殊字符，必须用\\为前导。转移符。\\-表示查找-，\\.表示查找.。 匹配支付类 操作符 | 说明——– |——-[:alnum:]| 任意字母和数字（同[a-zA-Z0-9]）[:alpha:]|任意字符（[a-zA-Z]）[:blank:]|空格和制表（同[\\t]）[:digit:]|任意数字[同0-9][:graph:]|与[:print:]相同，但不包含空格[:lower:]|任意小写字母[a-z][:print:]|任意可打印字符[:space:]|包括空格在内的任意空白字符[:upper:]|热议大写字母（同[A-Z]） 匹配多个实例以上的正则表达式，都表示匹配单词出现，如果需要多次匹配，则需要使用重复元字符 元字符 说明 * 0个或者多个匹配 + 1个或多个匹配（等于{1，}） ？ 0个或多个匹配（{0,1}） {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围（不超过255个） 12345select prod_name from products where prod_name regexp &apos;\\\\([0-9] sticks?\\\\)&apos;order by prod_name;##正则表达式\\\\([0-9] sticks?\\\\) sticks?匹配stick和sticks（s后面的问号是s可选，因为？匹配它前面的任何字符出现0次或者1次出现）。使用问号可以轻松匹配出stick或者sticks。 123select prod_name from produts where prod_name regexp &apos;[[:digit:]]&#123;4&#125;&apos;##[:digit:]代表任意数字，因而它为数字的一个集合.&#123;4&#125;确切的要求它前面的字符（任意数字）出现4次，所以该表达式表示连在一起的任意4个数字。 定位符以上都是匹配一个字符串任意位置的文本。为了匹配指定位置的文本，需要使用定位符 元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 `mysqlselect prod_name from productswhere prod_name regexp ‘^[0-9\\.]’order by prod_name; ##^表示从字符串的开头，匹配第一个字符为数字或者点的情况下返回结果","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Mysql简介","slug":"Mysql简介","date":"2019-02-17T09:37:06.000Z","updated":"2019-02-17T09:39:26.941Z","comments":true,"path":"2019/02/17/Mysql简介/","link":"","permalink":"http://yoursite.com/2019/02/17/Mysql简介/","excerpt":"","text":"Mysql简介这里开始学习sql语句 登录到数据MySql在具有可供使用的MySql DBMS和客户机软件之后，要求在能执行命令个之前先登录到DBMS。MySql在内部保存有自己的用户列表，并且把每个用户和各种权限关联在一起。 在最初安装mysql时，通常会创建一个管理登录，一般为root和一个密码。 为了连接到MySql，需要以下信息：1、主机名（计算机名）–如果连接到本地Mysql服务器，为localhost。2、端口（如果使用默认端口3306之外的端口）3、一个合法的用户名4、用户口令 选择数据库在你最连接到数据库时，并没有任何打开的数据库功能使用，在你能执行数据库操作前，需要选择一个数据库。使用关键字==use==，选择数据库crashcourse1234输入：USE crashcourse;输出：Database changed 注：必须使用use先打开数据库，才能读取其中的数据 了解数据库和表查看数据库列表,使用关键字show，将显示所有的数据库。12输入：SHOW DATABASES; 查看数据库内，包含表的列表同样使用关键字，将显示所有的数据库的表的列表。1show tables； ##显示数据库所有的表列 show也可以用来显示表列123show columns from customers; ##显示customers表中的所有列上面语句等于：describe customers; 所支持的其他show语句还有：12show status; ##显示广泛的服务器状态信息；show creat database 和 show create table; ##分别用来显示创建特定数据库或表的Mysql语句； 检索数据 select 语句检索单个列1select prod_name from products; ##从products表中检索一个名为prod_name的列；该检索出来的结果是为排序的数据 ==注意多条sql语句必须以分号（；）分隔，sql语句不区分大小写==检索多个列1select prod_id,prod_name,prod_price from products; ##从products表中检索prod_name，prod_price,prod_id三列数据 检索所有的列1select * from produts; ## *表示从检索products表中的所有数据； 检索不同的行select 语句返回所有的匹配，中就可能包好重复的记录，要返回不重复的记录徐亚使用更关键值distinct1select distinct vend_id from products; ##关键字distinct表示只返回vend_id列中不同的记录 限制结果select 语句返回所有的行，他们可能是指定表中的每个行。12select prod_name from products limit 5; ##返回prod_name列的前5行。select prod_name from products limit 5,5; ##返回从行5开始的5行。第一个数为开始的位置，第二个数为要检索的行数。 使用完全限定的表名1select products.prod_name from crashcourse.products; ##指定表名，数据库名 排序检索数据排序数据 关键字order by1234select prod_name from products order by prod_name; ##检索prod_name列，并对其按字母顺序进行排序 select prod_id,prod_price,prod_name from products order by prod_price,prod_name; ##首先按照价格排序，在价格一样的情况下再对prod_name按照字母顺序排列； 指定排序方向 关键字desc12select prod_id,prod_price,prod_name from products order by prod_price desc; ##关键字desc指定一只母顺序方向排序；select prod_id,prod_price,prod_name from products order by prod_price desc,prod_name; ##先按降序对prod_price排序，在prod_price相同的情况下对prod_name排序 ==desc只对位于其前面的列名起作用==，对于prod_name则不起作用。如果要对多个列进行降序排序，必须对每一个列都指定desc关键字使用order by 和limit组合可以查询最值1select prod_price from products order by prod_price limit 1; ##检索出prod_pice 列中最大的值 过滤数据在select语句中，数据根据where子句中指定的搜索条件来进行过滤1select prod_name,prod_price from products where prod_price = 2.5; ##检索prod_price=2.5的记录； wehre子句的操作符号操作符 |说明——– | ——-=|等于&lt;&gt;|不等于！=|不等于&lt;|小于&lt;=|小于等于 |大于=|大于等于between|在指定的两个值之间检查单个值1234select prod_name,prod_price from products where prod_name =&apos;fuses&apos;; ##返回prod_name为fuses的一行select prod_name,prod_price from products where prod_price &lt;10; ##返回prod_price小于10 的行select vend_id,prod_name from products where vend_id &lt;&gt;1003; ##返回vend_id不等于1003的行 select vend_id,prod_name from products where vend_id != 1003; ##返回vend_id不等于1003的行 范围值检查12select prod_name,prod_price from products where prod_price between 5 and 10;##检索prod_price为5到10之间的记录，包括本身。 空值检查在创建表的时候，表设计人员可以指定其中的列是否可以不包含值，一个列不包含值时，称其为包含空值NULL。1select prod_name from products where prod_price is null; ##返回价格为空的行，而不是价格为0的记录。 数据过滤组合where子句Mysql允许给出多个where子句。这些子句可以用两种方式使用：以and子句或or子句的方式使用。 and操作符为了通过不止一个列进行过滤，可使用AND操作符给where子句附加条件。 12select prod_id,prod_price,prod_name from products where vend_id =1003 and prod_price &lt;=10; ##and用在where子句的关键字，用来指示满足所有给定条件的行。同时满足两个条件。 or操作符or操作符与and操作符不同，它指示mysql检索匹配任意一条件的行。 12select prod_name,prod_price from products where vend_id =1002 or vend_id =1003; ##or用在where后面，表示满足任意条件都匹配一行。 or操作符和and操作符同时存在的计算次序where可包含任意数目的and和or操作符。允许两者结合以进行复杂和高级的过滤。 12select prod_name,prod_price from products where vend_id =1002 or vend_id=1003 and prod_price &gt;=10;##sql在处理or操作数的时候，优先处理and操作符。 所以先，匹配vend_id =1003的并且价格大于等于10的行，之后再匹配vend_id=1002，的行。 in操作符圆括号在where子句中，还有另外一种用法。IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。 1select prod_name,prod_price from products where vend_id IN (1002,1003) order by prod_name; ##此select语句检索供应商1002和1003制造的所有产品。 not in not操作符有且只有一个功能，那就是否定它之后跟的任何条件。==此时看，in操作符，和or操作符具有相同的功能== ==in操作符的执行速度较快于or操作符== 用通配符进行过滤 LIKE操作符通配符：用来匹配值的一部分的特殊字符。为了在子句中使用通配符，必须使用LIKE操作符。百分号通配符：%表示任何字符出现任意次数。1select prod_id,prod_name from products where prod_name LIKE &apos;jet%&apos;; ##搜索所有的一jet开头的name。 下划线通配符：只匹配单个字符而不是多个字符。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"检索数据","slug":"检索数据","permalink":"http://yoursite.com/tags/检索数据/"}]},{"title":"linux学习","slug":"linux基础","date":"2019-02-16T15:34:29.000Z","updated":"2019-02-16T16:02:39.070Z","comments":true,"path":"2019/02/16/linux基础/","link":"","permalink":"http://yoursite.com/2019/02/16/linux基础/","excerpt":"","text":"基础部分分区hd 硬盘 hda hdb hdc 表示abc 三个硬盘sata 硬盘 sd sda sdb sdc 表示abc 三个硬盘hda1 hda2 hda3 表示第一个硬盘的1、2、3分区sda1 sda2 sda3 表示第一个硬盘的1、2、3分区 挂载点：windows 分区，必须给每一个分区分配一个盘符；才能够看到及使用该分区。 在linux下自由/可以当盘符，所以其他的分区，都得在/下创建文件。挂载点就是/下面创建的路径。 网卡linux网卡，使用eth来表示，windows下使用本地连接来表示。 一台电脑装多个操作系统的话，系统不能安装到同一个分区下。window系统只能装在主分区里面。 在linux里面以点号开头的，都是隐藏文件。 图形化界面与命令行切换图形化界面同命令行的切换，linux一般有七个控制台，1到6个都是字符界面，第7个是图形化界面。ctl + alt + f1~f6，切换控制台。 ctl + alt + f7 ，图形化界面。 控制台又称之为入口，通过这七个控制台都可以登入到系统。 使用命令tty 可以查看当前所在第几个控制台。 命令的执行linux中命令的格式。 命令 -选项… 参数 （选项表示如何执行该命令）（-后面跟的是选项） ls -h (-h 选项以能看懂的方式显示大小)（当选项是一个单词整体的时候，前面需要两条 杠 –）在命令行执行命令时候的声音执行命令 modprobe -r pcspkr，root用户下。 快捷键：ctl +a 光标跳到本行的开头。 ctl +e 光标跳到本行末尾。再按住左右建，一个单词一个单词的跳 ctl +u 光标位置删除到本行的开头 ctl +k 当前光标一直删除到本行的结尾。执行命令：touch xx 后再执行命令 ^xx ^yy，表示重新执行前一个命令，并将xx替换成yy执行一遍 相当于执行了一遍：touch yy。ctl +shift +t 打开新的终端，ctl +shift +pageup或者+pagedown切换终端。 命令whatis +命令 该命令用来解释该命令有什么作用，显示不同的章节–help 告诉具体的用法。若选项或文件用[]括起来的话，表示该选项或者文件可以省略。 …表示可以有多个选项或者文件 小写的n从上往下查找，大写的N表示从下往上查找。 /^des该命令表示查找开头为des的单词，尖括号表示开头。 若某个命令只能记住一部分，可以使用 命令：man -k能记住的部分，此后将会显示全部包含该部分的命令。man 还可以查询配置文件的使用方法。帮助文档存放在/usr/shoare/doc里面。 man +命令 查看命令使用方法，默认的是显示第一章。。若要查询别的章节使用：man 章节 +命令 文本编辑：gedit 图形化编辑。 运行级别运行级别 不同的运行级别里面，运行的服务不一样。linux中 /etc/init.d 或者 rc.d/inid.d 然后运行的级别就是在rc.d里面的7个不同的级别。不同的级别就运行对应的rc5.d,里面的服务，，服务以K开头的表示该服务停止运行。 查看运行级别的命令：runlevel图形化界面在级别5.级别1单用户模式。级别3 存文本模式，在存文本级别下可以手动打开图形界面，执行命令：startx，虽然启动了图形化界面，但是运行级别未改变。级别6 重启 每个级别进入系统都有7个控制台。 忘记root密码","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/初学者/"}]},{"title":"MySql基础","slug":"MySql","date":"2018-09-21T15:34:29.000Z","updated":"2018-09-21T16:35:06.781Z","comments":true,"path":"2018/09/21/MySql/","link":"","permalink":"http://yoursite.com/2018/09/21/MySql/","excerpt":"","text":"数据库基本概念数据库是：一个以某种有组织的方式存储的数据集合。数据库（database）保存有组织的数据容器（通常是一个文件或是一组文件）。数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操作的容器。（用户并不直接访问数据库，而是通过DBMS，他替你访问数据库） 组成1. 表（table）表是一种结构化的文件，可以用来存储某种特定类型的数据，某种特定类型数据的结构化清单。表名的唯一性取决于多个因素，如数据库名和表名等的结合。相同的数据库中不能两次使用相同的表名，但是在不同的数据库中却可以使用相同的表名。 2. 模式（schema）描述表的这组信息就是所谓的模式,模式可以用来描述数据库中的特定的表以及整个数据库。关于数据库和表的布局及特性的信息。 3. 列（column）和数据类型列： 表中的一个字段。所有的表都是由一个或者多个列组成的。数据类型： 说容许的数据类型。每个表都有相应的数据类型，它限制（或容许）该列中存储的数据。数据类型限制可存储在列中的数据类型。在创建表时必须对数据类型给予特别的关注。 4. 行（row）表中的数据是按照行储存的，所保存的每个记录存储在自己的行内。 表中的行数为记录的总数。你可能在听到用户在提到行（row）时称其为数据库的记录（record）。 5. 主键（primary key）表中的每一行都应该有可以唯一标识自己的一列（或一组）。其值能够唯一区分表中每个行。唯一标识表中每行的这个列（或这组列）称为主键。表中的任何列都可以作为主键，他只要满足一下条件 (1.)任意两行都不具有相同的主键值 (2.)每个行都必须具有一个主键值（主键列不允许NULL值）。 什么是SQL1.sqlsql是一种专门用来与数据库通信的语言","categories":[{"name":"MySql","slug":"MySql","permalink":"http://yoursite.com/categories/MySql/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/初学者/"}]},{"title":"测试","slug":"测试","date":"2018-09-16T14:51:56.000Z","updated":"2018-09-16T16:05:57.185Z","comments":true,"path":"2018/09/16/测试/","link":"","permalink":"http://yoursite.com/2018/09/16/测试/","excerpt":"你就可以看到你的博客了，今天学习了hexo+github搭建个人免费博客。刚开始是完全不知道怎么弄，就是这一点点的在网上查资料，然后慢慢摸索，直到现在大概用了6/7个小时左右几乎，就搭建好了自己的博客，基本的用法基本上已经能够使用呢，就是还有些细节问题还需要进一步的，学习。还需要进一步的完善改进自己的博客的样式，能让他达到完美的状态。","text":"你就可以看到你的博客了，今天学习了hexo+github搭建个人免费博客。刚开始是完全不知道怎么弄，就是这一点点的在网上查资料，然后慢慢摸索，直到现在大概用了6/7个小时左右几乎，就搭建好了自己的博客，基本的用法基本上已经能够使用呢，就是还有些细节问题还需要进一步的，学习。还需要进一步的完善改进自己的博客的样式，能让他达到完美的状态。 基本要求基本能力1世间只有公道，付出总有回报。其实付出不一定有回报，但是可以确定的是，没有付出是绝对没有回报的 是不是就是这个样子呢 决心表态more info: qzone 继续学习weizhsdfsdfwe ewrferfer 努力努力永不放弃撒大声地萨达所大所奥术大师多啥多日热污染啥多 这一次不知道能是的份上废物 书得我些的清单群无都是我的无就是是这样的所以所以每一次都需要进一步的学习 整理资料努力努力整理资料的重要性可以直接执行复制的工作的就是这样的额简单明年加油加油加油","categories":[],"tags":[{"name":"文本格式魔板测试","slug":"文本格式魔板测试","permalink":"http://yoursite.com/tags/文本格式魔板测试/"}]},{"title":"my-first_blog","slug":"my-first-blog","date":"2018-09-16T11:26:07.000Z","updated":"2018-09-16T11:33:13.709Z","comments":true,"path":"2018/09/16/my-first-blog/","link":"","permalink":"http://yoursite.com/2018/09/16/my-first-blog/","excerpt":"","text":"今天学习了怎样使用hexo+github免费搭建博客并自己搭建了博客，虽然还不是很熟悉，但是需要慢慢的来学习其中更多的知识，让这个成为一个很好的开端，以后做自己想做的事情，不落后别的同学；","categories":[],"tags":[{"name":"学习、学习、努力","slug":"学习、学习、努力","permalink":"http://yoursite.com/tags/学习、学习、努力/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-15T14:30:42.123Z","updated":"2018-09-16T11:53:08.459Z","comments":true,"path":"2018/09/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/09/15/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}